head	1.1;
access;
symbols;
locks
	jls:1.1; strict;
comment	@ * @;


1.1
date	2003.01.24.19.25.11;	author jls;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@
%{
#include <FlexLexer.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h> 
#include <iostream>
#include <sstream>
#include <fstream>
#include "f0.h"
#include "st.h"
#define MYdouble long double;
using namespace std;
int insert_st(st_struct st[], char * yytext);
int look_st(st_struct st[], char * yytext);
int insert_st(st_struct st[], string yytext);
int look_st(st_struct st[], string yytext);
void error(char * error, int tok);
st_struct st[MAXTS];   // store for variables/constants
st_mycode mc[MAXTS];   // array to store the lines of code
int levelvar[MAXTS];   // array of indexes to replace variables in diff eqn
int mylineno=1;
int lastid=1;
int nconstants=0;
int codelineno=0;
long double lastnumber;
int nomore = 0;
char myeq0[MAXLINE]; 
string myvar1;
// FOR FIGURES 
int nfigs =0;
int tfigs[MAXTS];
%}

alpha    [A-Za-z_]
dig      [0-9]
id       ({alpha})({alpha}|{dig})*
num1     -?{dig}+\.?([eE][-+]?{dig}+)?
num2     -?{dig}*\.{dig}+([eE][-+]?{dig}+)?
number   {num1}|{num2}
idarray  {id}[(]{dig}+[)]
%%

{number}            {    
                    lastnumber = atof(yytext);
                    return NUMBER;  }

$[Ee]quations           { return EQUATIONS; }
$[Pp]lot                { return PLOT; }
$[Ii]nitial_[Cc]onditions  { return INITIAL_CONDITIONS; }
$[Pp]arameters_file     { return PARAMETERS_FILE; }
$[Mm]ethod              { return METHOD;}
$[Ss]tartTime           { return FROM_T; }
$[Ss]topTime            { return TO_T; }
$[Tt]imestep            { return TIMESTEP; }
$[Tt]imefigs            { return TIMEFIGS; }
$[Rr]k4                 { return RungeKutta4th; }
$[Aa]daptiveRk4         { return CashKarpRungeKutta;}
$BSStepPoly             { return BSStepPoly; }
$BSStepRational         { return BSStepRational; }
$RosenStiffJacob        { return RosenStiffJacob; }
$[Uu]                   { return UNIFORM; }
$[Tt]                   { return TRIANGULAR; }
$[Cc]                   { return CINTERVALTYPE; }
$[Ll]                   { return LOGTYPE; }
";"                     { return SEMI_COLON; }

"abs"|"exp"|"ceil"|"floor"|"log"|"sqrt"|"int"|"sinh"|"cosh"|"tanh"|"sin"|"cos"|"tan"|"asin"|"acos"|"atan"|"min"|"max"|"pow"|"pow10"|"log10"|"hypot"|"cbrt"|"atan2"|"exp10"|"frexp"|"ldexp"|"modf"|"fabs"|"fmod"|"ratio1"|"ratio2"    { return FUNCTION; }

{idarray}             {
  int pos1;
  myvar1 = yytext;
  pos1 = myvar1.find('(',0);
  if (pos1 == 0) error("should be parleft at line",mylineno);
  myvar1.replace(pos1,1,"_");
  pos1 = myvar1.find(')',0);
  if (pos1 == 0) error("should be parclose at line",mylineno);
  myvar1.replace(pos1,1,"_");
  if (nomore==1) lastid = look_st(st,myvar1);		       
  else 
    { 
      lastid = insert_st(st, myvar1);
      st[lastid].type = IDENTIFIER;
    }
  return IDENTIFIER;                       
  }

{id}                    {                 
  if (nomore==1) lastid = look_st(st,yytext);
  else
    { 
      lastid = insert_st(st, yytext);
      st[lastid].type = IDENTIFIER;
    }
  return IDENTIFIER;
   }

"'"                      { return APOSTROPHE; }

=                {  return ASSIGNMENT ; } 

"{"[^}\n]*"}"     /* eat up one-line comments */

[ \t\r]+          /* eat up whitespace */

\n              mylineno++;

"//"|"%"    {  int c;           
                   while ( (c = yyinput() ) != 0)
                   {  if (c == '\n')
                     { ++mylineno;
                       break;
                      }
                }
          /*  printf("Line %d comment", mylineno);  */
        }

"/*"    {
                   int c;
                   while((c = yyinput()) != 0)
                       {
                       if(c == '\n')
                           ++mylineno;
                       else if(c == '*')
                           {
                           if((c = yyinput()) == '/')
                               break;
                           else
                               unput(c);
                           }
                       }
                   }

","|"("|")"|"+"|"-"|"/"|"*"|">"|">="|"=="|"<"|"<="|"!="|"?"|":"  { return OPERATOR; }

.          { printf( "Line %d:  Unrecognized character: %s\n", mylineno, yytext );
 return(yytext[0]);  error("Unrecognized character in line ", mylineno); 
exit(1); }

%%

int yywrap() { return 1; }

using namespace std;
data t;

void init_st(st_struct st[])
{	
  int i=1;
  for (i=0; i<MAXTS; i++)
	 {
		st[i].name = "";
      st[i].dfequation = "";
      st[i].constequation = "";
      st[i].eqname = "";
      st[i].constname = "";
      st[i].object = MAX_KEY_TS;      // number of entries on the table
      st[i].type = 0;
      st[i].var_type = 0;
      st[i].p_diffeq = 0;
      st[i].initialized = 0;
      st[i].declaration = 0;
      st[i].declared_here=0;
      st[i].begin_range = 0;
      st[i].mid_range  = 0;
      st[i].end_range = 0;
      levelvar[i] = 0;
    }
    st[0].name = "TimeAct";
    st[0].constname = "TimeAct";
    st[0].eqname = "TimeAct";
}

int look_st(st_struct st[], string yytext)
{ int i, foundhere;
   string a;
   foundhere=0;
   a = yytext;
   for (i=0; i<=t.lastid; i++)
	 { 		
	     if (a == st[i].name)
                  {                                 
		     return i;			
		  }
	 }
   return 0;
}

int look_st(st_struct st[], char * yytext)
{ int i, foundhere;
   string a;
   foundhere=0;
   a = yytext;
   for (i=0; i<=t.lastid; i++)
	 { 		
	     if (a == st[i].name)
                  {                                 
		     return i;			
		  }
	 }
   return 0;
}

int insert_st(st_struct st[], string  yytext)
{
   int i, foundhere;
   string a;
   foundhere=0;
   a = yytext;
   foundhere = look_st(st, yytext);
   if (foundhere == 0)
	{
	  if (t.lastid >= MAXTS) error("Symbol table too small, please increase the constant MAXTS, error found at ",mylineno);
	  t.lastid++;
	  st[t.lastid].name = a;
	  st[t.lastid].declared_here = foundhere;
	  //  cout << "A Inserting " << a << endl ;
	  return t.lastid; 
   }
   else { return foundhere;  }
}

int insert_st(st_struct st[], char * yytext)
{
   int i, foundhere;
   string a;
   foundhere=0;
   a = yytext;
   foundhere = look_st(st, yytext);
   if (foundhere == 0)
    {
		if (t.lastid >= MAXTS) error("Symbol table too small, please increase the constant MAXTS, error found at ",mylineno);
      t.lastid++;
      st[t.lastid].name = a;
      st[t.lastid].declared_here = foundhere;
		// cout << "B Inserting " << a << endl ;
     return t.lastid; 
   }
   else { return foundhere;  }
}

void error(char * ab, int tok)
{
  printf("Error: %s %d \n", ab, tok);
  exit(1);
}

void error(string ab)
{ cout << "Error: " << ab  << endl;
 exit(1);
}

int main( int argc, const char * * argv )
{
    ++argv, --argc;  /* skip over program name */
    FlexLexer* lexer = new yyFlexLexer;

	 //	if ( argc > 0 )
	 //		  yyin = fopen( argv[0], "r" );
	 //else
	 //	  yyin = stdin;

    int token; 
	 int mymethod=0;
    float neq;
    t.lastid=0;
    char myeq[MAXLINE];
    string buf;
    string myequation1;
    ostringstream out(buf);    
    init_st(st);
    int i, pointerid;
    // checking if all equations' have initial conditions.
    // build variables list
    string list_var;   
    int ninitial_conditions = 0;
	 // while here !
    token = lexer->yylex();
    nomore = 0;
    if (token == INITIAL_CONDITIONS)
      {
		  token = lexer->yylex();
        if (token!= IDENTIFIER)
			 error("Expecting an identifier in line ", mylineno);		  
		  while (token == IDENTIFIER)
			 {        
				myequation1="";
				pointerid = lastid;
				token = lexer->yylex();	   
				if (token != ASSIGNMENT) error("Expecting  =  in line ", mylineno);
				token = lexer->yylex();
				while ((token == IDENTIFIER) || (token == OPERATOR) || (token == NUMBER)|| (token == FUNCTION) || (token == UNIFORM) || (token == TRIANGULAR)   || (token == CINTERVALTYPE)  || (token == LOGTYPE) ) 
				  {  if (token == IDENTIFIER)
					 {
						myequation1 = myequation1+st[lastid].name+" ";
					 }
				  else
					 myequation1 = myequation1+lexer->YYText()+" ";
				  token = lexer->yylex();				    
				  }
				if (token != SEMI_COLON) error("Expecting ; in line ", mylineno);
				st[pointerid].constequation = myequation1;
				st[pointerid].initialized = 1;  
				ostringstream out(buf);
				out << pointerid;
				st[pointerid].constname = "C["+ out.str()+"]"; 
				//	cout << pointerid << " : " << st[pointerid].name << ", " << st[pointerid].constname << " " << st[pointerid].constequation << endl;		    
				 if (st[pointerid].var_type == 0) 
				   st[pointerid].var_type = CONST;	    
				 ninitial_conditions++;
				 mc[codelineno].variable = pointerid;
				 mc[codelineno].linecode = myequation1;
				 codelineno++;
				 token = lexer->yylex();
			 }
      }
    int nequations = 0;
    if (token == EQUATIONS)
      {  
		  token = lexer->yylex(); 	
		  i = 0;
		  while (token == IDENTIFIER)
			 { 	      
			   nequations++;
			   pointerid = lastid; 
			   myequation1="";
			   token =lexer->yylex();
			   if (token == APOSTROPHE) // Level equation 
			     {
			       st[pointerid].var_type = LEVEL; 
			       token = lexer->yylex();
			       if (token != ASSIGNMENT)
			       error("Expecting = in line", mylineno);
			       token = lexer->yylex();
			       //   cout << token << endl;
			       while ((token == IDENTIFIER) || (token == OPERATOR) || (token == NUMBER) || (token == FUNCTION)) 
				 {
				   if (token == IDENTIFIER)
				     myequation1 = myequation1+st[lastid].name+"";
				   else
				     myequation1 = myequation1+lexer->YYText()+"";
				   token = lexer->yylex();				    
				 }
			       if (token != SEMI_COLON) error("Expecting ; in line ", mylineno);
			       st[pointerid].dfequation = myequation1;
			       if (st[pointerid].eqname == "") {
				 ostringstream out(buf);
				 out <<  nequations;
				 st[pointerid].eqname = "y["+out.str()+"]"; 
			       }
			       else error("Error, you are modifing a derivative equation at line ", mylineno);
			     }
			   else
			     { 
			       if (token != ASSIGNMENT)
				 error("Expecting = in line ", mylineno);
			       token = lexer->yylex();
					 
					 while ((token == IDENTIFIER) || (token == OPERATOR) || (token == NUMBER) || (token == FUNCTION))
						{
						  if (token == IDENTIFIER)
							 myequation1 = myequation1+st[lastid].name+"";
						  else
							 myequation1 = myequation1+lexer->YYText()+"";
						  token = lexer->yylex();				    
						}
			       if (token != SEMI_COLON) error("expecting ; in line ", mylineno);
			       st[pointerid].dfequation = myequation1;
			       ostringstream out(buf);
			       out <<  nequations;
			       if (st[pointerid].eqname == "")
			       {    st[pointerid].var_type = AUX;
			           st[pointerid].eqname = "AUX["+out.str()+"]"; 
				   }
			       else
			          error("Error, you are modifing an auxiliar equation at line  ", mylineno);
			     }
			   st[pointerid].declaration = 1;
			   mc[codelineno].variable = pointerid;
			   mc[codelineno].linecode = st[pointerid].dfequation;
			   codelineno++;
			   levelvar[nequations] = pointerid;		
			   st[pointerid].p_diffeq = nequations;
			   token = lexer->yylex();  
			   i++;
			 }
      }
    // check simulation parameters	
    double xfromt=1.0, xtot=1.0, xtimestep=1.0, xtimefigs = 1.0;
    if (token == FROM_T)
         { 
			  token = lexer->yylex();
			  if (token != NUMBER) error("Expecting a number at line", mylineno);
			  xfromt = lastnumber;
			  token = lexer->yylex();
			}
    if (token == TO_T)
      {
		  token = lexer-> yylex();
		  if (token != NUMBER) error("Expecting a number in to-t ");
		  xtot = lastnumber;
		  token = lexer->yylex();
      }
	 if (xtot < xfromt) error(" error in time interval, fromt should be more than tot ", mylineno);
    if (token == TIMESTEP)
      {
		  token = lexer->yylex();
		  if (token != NUMBER) error("Expecting a timestep ");
		  xtimestep = lastnumber;
		  if (xtimestep <= 0.000000001) error ("Timestep too small :", mylineno);
		  token = lexer->yylex();
      }
	 if (token == TIMEFIGS)
      {
		  token = lexer->yylex();
		  if (token != NUMBER) error("Expecting a time for figures ");
		  xtimefigs = lastnumber;
		  if (xtimefigs <= 0.000000001) error("number too small to plot intervals: ", mylineno);
		  token = lexer->yylex();
      }
    nomore = 1;
	 if (token == PLOT)  // syntax: $display variable ... ;
		{  // time is the first implicit variable
		  //  cout << " Plot" << endl;
		  tfigs[0] = 0;
		  token = lexer->yylex();
		  // cout << "Token =" << token << endl;
		  while(token == IDENTIFIER)
			 {
				nfigs++;
				if (lastid == 0) error("Display: undeclared variable in line ", mylineno);
				tfigs[nfigs] = lastid;
				token = lexer->yylex();				
				//cout  << st[nfigs].name <<  " ";
			 }
		  if (token != SEMI_COLON) error("Expecting an identifier or ; in line",mylineno);		  		
		}
	  token = lexer->yylex();
    // check method
	 if (token == METHOD)
		{
		  token = lexer->yylex();
		  if (token == RungeKutta4th)
				mymethod = RungeKutta4th;
		  else
		  if (token ==  CashKarpRungeKutta)
				mymethod = CashKarpRungeKutta;
		  else
			 if (token ==  BSStepPoly)
				mymethod =  BSStepPoly;		  
		    else
				if (token == BSStepRational)
				  mymethod = BSStepRational;
				else
				  if (token == RosenStiffJacob)
					 mymethod =   RosenStiffJacob;
		        else 
					 error("Unknown method at line", mylineno);
		}
     
    if (mymethod == 0) error("Please include a method ($Rk4, $AdaptiveRk4, $BSStepPoly, or $BSStepRational) ", mylineno);
	 if (ninitial_conditions == 0) error("Please add $Initial_conditions.  ", mylineno);
	 if (nequations == 0) error("Please add $equations at line ", mylineno);
    // save equations on a file to check syntax

    ofstream temp("temp.c");
    ofstream equations("equations.c");
    temp << "/*  */ " << endl;
    temp << "#include <stdio.h> " << endl;
    temp << "#include <math.h>  " << endl;
    temp << "int main() {" << endl;
    temp << "double TimeAct; " << endl;
	 // print the symbol table first!
	 //	 equations << "/* no declared variables */" << endl;  
	 //	 for (i=1; i<=t.lastid; i++)
	 //		if (st[i].initialized == 0) // not initialized with equations
	 //		  equations << "double " << st[i].name << " = 0.0; " << endl; 
	 // equations << "/* end of not declared variables */ " << endl;
     for (i=0; i< codelineno; i++)
      {
		  if (i < ninitial_conditions)
	  {	  
		 equations << "double ";
		 equations << st[mc[i].variable].name << " =  " << mc[i].linecode << ";" << endl; }
    	  else
	   equations << st[mc[i].variable].name << " =  "  << mc[i].linecode << ";" << endl;
      }
    temp << "#include \"equations.c\" " << endl;
    temp << "return 0; }" << endl;
    temp.close();
    equations.close();
	 //    system("g++ -o temp0 temp.c -lm");
    
   // If OK then read the file and continue using flex
   // here to replace the variables
   // reset 
   // build arrays for va
	 nomore =1; // no more insertions in symbol table
 int j;
 // create the file temp1.c where the output of the code is:
 // 
 ofstream temp1("temp1.c");
 temp1 << "/*  Program generated by teval, a translator and LHS evaluator written by Jose L. Segovia, 2002-03. */ " << endl;
 temp1 << "#include <stdio.h> " << endl;
 temp1 << "#include <stdlib.h> " << endl;
 temp1 << "#include <math.h>  " << endl;
 temp1 << "#include <time.h>  " << endl;
 temp1 << "#define NRANSI " << endl;

 // if (mymethod == CashKarpRungeKutta)
	{
 temp1 << "#include "<<(char)34 << "my_nr.h" << (char)34 << endl;
 temp1 << "#include "<<(char)34 << "nrutil.h" << (char)34 << endl;
 temp1 << "double dxsav,*xp,**py;  /* defining declarations */ " << endl;
 temp1 << "int kmax,kount; " << endl;
 temp1 << "int nrhs;   /* counts function evaluations */ "<< endl;
}
	// temp1 << "typedef struct {char name[50];  float max, min; } eqfig; " << endl;;    
 temp1 << "#define NINC " << ninitial_conditions << endl;
 temp1 << "#define N " << nequations << endl;
 temp1 << "#define NFigs " << nfigs << endl;
 temp1 << endl;   
 
 // if (mymethod == RosenStiffJacob)  // add jacobian
	{ 
	  temp1 << "void jacobn(float x, float y[], float dfdx[], float **dfdy, int n,  double C[], double AUX[]) " << endl;
     temp1 << "{	int i; /* Called by the stiff function. Please delete this code and include yours. */ " << endl;
	  temp1 << " /*            for (i=1;i<=n;i++) dfdx[i]=0.0; " << endl; 
	  temp1 << " dfdy[1][1] = -0.013-1000.0*y[3];  " << endl;
	  temp1 << " dfdy[1][2]=0.0; " << endl; 
	  temp1 << " dfdy[1][3] = -1000.0*y[1]; " << endl;
	  temp1 << " dfdy[2][1]=0.0; " << endl;
	  temp1 << " dfdy[2][2] = -2500.0*y[3]; " << endl; 
	  temp1 << " dfdy[2][3] = -2500.0*y[2]; " << endl;
	  temp1 << " dfdy[3][1] = -0.013-1000.0*y[3]; " << endl;
	  temp1 << " dfdy[3][2] = -2500.0*y[3]; " << endl;
	  temp1 << " dfdy[3][3] = -1000.0*y[1]-2500.0*y[2];         */ " << endl;
	  temp1 << "};  " << endl;  
	}
 temp1 << "void derivs(double TimeAct, double y[], double dydx[], double C[], double AUX[]) " << endl;
 temp1 << "{" << endl;
 // if (mymethod == CashKarpRungeKutta)
	{
	  temp1 << "	nrhs++; " << endl; 
   }
 for (i=ninitial_conditions; i< codelineno; i++)
    {
      if (st[mc[i].variable].var_type == LEVEL)
	temp1 << "\t" <<  "dydx[" << st[mc[i].variable].p_diffeq << "]=  ";	
      else
	temp1 << "\t" << st[mc[i].variable].eqname << "=  "; 
      //  cout << i << ": " << mc[i].linecode << endl;
      istringstream StringFlow(mc[i].linecode);
      token = lexer->yylex(&StringFlow, &cout);
      while(token != 0)
	{
	  if ((token == IDENTIFIER))
	    { 
	      if (st[lastid].eqname != "")
		temp1 << "" << st[lastid].eqname;
	      else 
	       if (st[lastid].constname != "")
	          temp1 << "" <<  st[lastid].constname;
	       else
	          temp1 << " UNDECLARED_VARIABLE_HERE_PLEASE_CHECK_YOUR_SOURCE_FILE ";
	    }
	  else 
	    {
	      temp1 << ""  << lexer->YYText();	      
	    }
	  token = lexer->yylex();	 
	}
      temp1 << ";  ";
      temp1 << "\t\t /* " << st[mc[i].variable].name << "=" << mc[i].linecode << "; */" << endl;
	 }
	temp1 << "}" << endl;   

	temp1 << "void load_constants(double C[]) {  " << endl;
	temp1 << "\t /* Filling initial conditions */ " << endl;
   int printthis = 0;
	int flagids = 0;
	int my_lastid = 0; // For the constant identifier
  for (i=0; i< codelineno; i++)
   {
     if (i < ninitial_conditions)
       {
        // temp1 << "/* " << i << " */ " ;
         printthis = 0;
			temp1 << "\t " << st[mc[i].variable].constname << " =  ";
			istringstream StringFlow(mc[i].linecode);
			token = lexer->yylex(&StringFlow, &cout);
			flagids = 0; // to check just for one token to be assigned to the variable.
			if  ((token == IDENTIFIER) && (st[lastid].var_type == CONST))
			   temp1 << st[my_lastid].constname << " "; 
			else
			   temp1 << lexer->YYText() << " ";

			token = lexer->yylex(); 
			if (token != 0)
			  {	
				 if (token == NUMBER)
					st[mc[i].variable].begin_range = lastnumber;
				 else error("Expecting a number at Initial condition equation ", i+1);
				 token = lexer->yylex(); 
				 if (token == NUMBER)
					st[mc[i].variable].end_range = lastnumber;
				 else error("Expecting a number at initial condition equation ", i+1);
				 token = lexer->yylex(); 
				 if (token == NUMBER)
					{
					  st[mc[i].variable].mid_range = st[mc[i].variable].end_range;
					  st[mc[i].variable].end_range = lastnumber;					
					}
				 else error("Expecting a number at initial condition equation", i+1);
				 token = lexer->yylex(); 

				 // cout << token << endl;
				 
				 if (token == TRIANGULAR)
					st[mc[i].variable].type_range = "T";
				 else if (token == UNIFORM)
					st[mc[i].variable].type_range = "U";
				 else if (token == CINTERVALTYPE )
					st[mc[i].variable].type_range = "C";
				 else if (token == LOGTYPE )
					st[mc[i].variable].type_range = "L"; 
				 else
					error("Unknown range type, should be $U, $T, $C, or $L, at initial condition equation ", i+1);
			  }
			//	cout << i << " : " ;
			//	cout << st[mc[i].variable].name << "  " << st[mc[i].variable].begin_range << " ," << st[mc[i].variable].mid_range << "," << st[mc[i].variable].end_range << ", " << st[mc[i].variable].type_range << endl;
			temp1 << "; ";
			temp1 << "\t\t /* " << st[mc[i].variable].name << "=" << mc[i].linecode << "; */" <<   endl;
       }
   }
  temp1 << "\t }; " << endl;
  temp1 << "/* End of loading constants */ " << endl;



   // Filling auxiliary variables
   // Filling level variables with initial conditions

  temp1 << "void load_auxlevel(double AUX[], double y[], double C[]) {" << endl;
  temp1 << "\t /* Filling leval and aux variables with initial conditions */ " << endl;
  for (i=0; i< codelineno; i++)
    {
      if (i >= ninitial_conditions)
       {
			if  (st[mc[i].variable].constname > "")
			  temp1 << "\t " << st[mc[i].variable].eqname << " =  " << st[mc[i].variable].constname << "; \t /* " << st[mc[i].variable].name << " = */ " << endl;	 
			else
			   temp1 << "\t " << st[mc[i].variable].eqname << " =  0.0; \t /* " << st[mc[i].variable].name << " = */ " << endl;
       }
   }
  temp1 << "}; " << endl;
  temp1 << "\n"  << endl;
  // function to load figures data:

  temp1 << "void load_data_figures(float **FIGS, eqfig figdata[], int nfigs, int j, double y[], double C[], double AUX[], double x) { " << endl;
  temp1 << "\t int i; " << endl;
  temp1 << "\t\t  FIGS[0][j] = x; " << endl;
  for (i = 1; i<=nfigs; i++) 
	 {
		temp1 << "\t\t  FIGS["<<i<<"][j] = (float)"<< st[tfigs[i]].eqname << ";" << endl; 
		temp1 << "\t\t  if (figdata["<<i<<"].max < FIGS["<<i<<"][j]) { figdata["<<i<<"].max =  FIGS["<<i<<"][j]; } "<< endl;
		temp1 << "\t\t  if (figdata["<<i<<"].min > FIGS["<<i<<"][j]) { figdata["<<i<<"].min =  FIGS["<<i<<"][j]; } "<< endl;
	 }
temp1 << "} " << endl;

  temp1 << "int main (void) " << endl; 
  temp1 << "{ " << endl;
  temp1 << "\t time_t init_time=time(NULL), end_time; double mydifftime;" << endl; 
  // temp1 << "\t int borra = gettimeofday(init_time); " << endl;
  // from here functions 
  if (mymethod == RungeKutta4th)
	 {
  temp1 << "\t int i,j, resode; " << endl;
  temp1 << "\t double h, x=1.0, *y, *dydx, *yout, *C, *AUX; " << endl; 
  temp1 << "\t int nfigs = " << nfigs << ";" <<endl;
  temp1 << "\t eqfig figdata["<<nfigs+1<<"];" << endl;
  temp1 << "\t float **FIGS; " << endl;
  temp1 << "\t int maxloop =0, nloop =0; " << endl;
  temp1 << "\t y    =  dvector(1,N);  " << endl;
  temp1 << "\t dydx =  dvector(1,N); " << endl;
  temp1 << "\t yout =  dvector(1,N);  " << endl;
  temp1 << "\t C   =   dvector(1,NINC); " << endl;
  temp1 << "\t AUX =   dvector(1,N); " <<endl;
  int nrowsfigs= (int)((xtot-xfromt)/xtimefigs)+1;
  temp1 << "\t FIGS =  matrix(0," << nfigs+1<<",0," << nrowsfigs << ");" << endl;	
  temp1 << "\t for(i=1;i<=nfigs;i++) { figdata[i].max = -99999999.9999; figdata[i].min=-figdata[i].max; }; " << endl;
  for (i=1; i<=nfigs; i++)
	 temp1 << "\t  strcpy(figdata[" << i << "].name," << (char)34 << st[tfigs[i]].name << (char)34 << ");" << endl; 

  temp1 << "\t load_constants(C); " << endl;
  temp1 << "\t load_auxlevel(AUX,y,C); " << endl;  
  temp1 << "\t /* ---rk4--- */ " << endl;
  temp1 << "\t h = (double)" << xtimestep<< ";"  << endl;
  temp1 << "\t x = (double)" << xfromt << "; " << endl;
  temp1 << "\t maxloop = (int) (" << xtot << "/h);" << endl;
  temp1 << "\t nloop = " << xfromt << "; " << endl;
  temp1 << "\t j=1; "<< endl;
  temp1 << "\t while(nloop <= maxloop) {" << endl;
  temp1 << "\t\t derivs(x,y,dydx,C, AUX); " << endl;  
  temp1 << "\t\t rk4(y,dydx,N,x,h,yout,derivs, C, AUX); " <<endl;
  temp1 << "\t\t y = yout; " << endl;
  temp1 << "\t\t if (nloop % (int)ceil("<<xtimefigs << "/h) == 0) {" << endl;
  temp1 << "\t\t load_data_figures(FIGS, figdata, nfigs, j, y, C, AUX, x);" << endl;
  temp1 << "\t\t\t j++; }  " << endl;
  temp1 << "\t\t x = x + h;" << endl;
  temp1 << "\t\t nloop++; " << endl;
  temp1 << "\t }  " << endl;
  temp1 << "\tfor(i=1; i<="<<nrowsfigs<<"; i++) { " << endl;
  temp1 << "\t\t printf("<< (char)34 <<" %f   "<< (char)34 << ",FIGS[0][i]);" << endl;
  temp1 << "\t\t for(j=1; j<=nfigs; j++) printf(" << (char)34 << "%f \\t" << (char)34 << ",FIGS[j][i]); " << endl;
  temp1 << "\t printf("<<(char)34<<"\\"<< "n" << (char)34 << "); }; " << endl;
  temp1 << "\t WritePlotScript(1, nfigs, " <<nrowsfigs<<", figdata);" << endl;
  temp1 << "\t free_dvector(yout,1,N); " << endl;
  temp1 << "\t free_dvector(dydx,1,N); " << endl;
  temp1 << "\t free_dvector(y,1,N); " << endl;
  temp1 << "\t free_dvector(C,1,NINC); " << endl; 
  temp1 << "\t free_dvector(AUX,1,N); " << endl;
  temp1 << "\t free_matrix(FIGS,0,"<<nfigs+1<<",0," << nrowsfigs << ");" << endl;
  temp1 << "\t system(" << char(34) << "rm output1.ps; gnuplot plot.scr &" << char(34) << "); " << endl;  
  // temp1 << "\t system(" << char(34) << "gv output1.ps &"<< char(34) << "); " << endl;  

	 }
  else
	 {
		if ((mymethod == CashKarpRungeKutta) || (mymethod == BSStepPoly) || (mymethod == BSStepRational) || 
			 (mymethod == RosenStiffJacob ))
	 {
		temp1 << "\t int i,j,nbad,nok, resode; " << endl;	
		temp1 << "\t double eps=1.0e-5,h1="<<xtimestep<<",hmin=0.0,x1=" << xfromt << "; " << endl;
		temp1 << "\t double x2=" << xtot <<" ,*y, *C, *AUX; " << endl;
		temp1 << "\t int nfigs = " << nfigs << ";" <<endl;
		temp1 << "\t eqfig figdata["<<nfigs+1<<"];" << endl;
		temp1 << "\t float **FIGS; " << endl;
		temp1 << "\t int NPOINTS = (int)((x2-x1)/" << xtimestep << "); " << endl;
		temp1 << "\t y=  dvector(1,N); " << endl;
		temp1 << "\t xp= dvector(1,NPOINTS); " << endl;
		temp1 << "\t C = dvector(1,NINC);  " << endl;
		temp1 << "\t AUX=dvector(1,N);  " << endl;
		temp1 << "\t py=dmatrix(1,N,1,NPOINTS);   " << endl;

		temp1 << "\t FIGS =matrix(0,"<<nfigs+1<<",0,NPOINTS);" << endl;	 // 20 max No. of graphics
		temp1 << "\t for(i=1;i<=nfigs;i++) { figdata[i].max = -99999999.9999; figdata[i].min=-figdata[i].max; }; " << endl;
		for (i=1;i<=nfigs; i++)
		  temp1 << "\t  strcpy(figdata[" << i << "].name," << (char)34 << st[tfigs[i]].name << (char)34 << ");" << endl; 


		temp1 << "\t load_constants(C); " << endl;
		temp1 << "\t load_auxlevel(AUX,y,C); " << endl;  
		temp1 << "\t nrhs=0;  " << endl;
		temp1 << "\t kmax=NPOINTS-2;  " << endl;
		temp1 << "\t dxsav="<<xtimestep<<"; " << endl;
	 }
  if (mymethod == CashKarpRungeKutta)
		temp1 << "\t resode=odeint(y,N,x1,x2,eps,h1,hmin,&nok,&nbad,derivs, rkqs, C, AUX, FIGS, figdata, nfigs); " << endl;
  if (mymethod ==  BSStepPoly)
	   temp1 << "\t resode=odeint(y,N,x1,x2,eps,h1,hmin,&nok,&nbad,derivs,bsstep, C, AUX, FIGS, figdata, nfigs); " << endl;
  if (mymethod ==  BSStepRational)  // seems not a good method
	   temp1 << "\t resode=odeint(y,N,x1,x2,eps,h1,hmin,&nok,&nbad,derivs,bsstep_rz, C, AUX, FIGS, figdata, nfigs); " << endl;
  if (mymethod == RosenStiffJacob)
      temp1 << "\t resode=odeint(y,N,x1,x2,eps,h1,hmin,&nok,&nbad,derivs,stiff, C, AUX, FIGS, figdata, nfigs); " << endl;
  if ((mymethod == CashKarpRungeKutta) || (mymethod == BSStepPoly)  || (mymethod == BSStepRational) || RosenStiffJacob)
  {
  temp1 << "\tfor(i=1; i<=kount; i++) { " << endl;
  temp1 << "\t\t printf("<< (char)34 <<"%f\\t"<< (char)34 << ",FIGS[0][i]);" << endl;
  temp1 << "\t\t for(j=1; j<=nfigs; j++) printf(" << (char)34 << "%f\\t" << (char)34 << ",FIGS[j][i]); " << endl;
  temp1 << "\t printf("<<(char)34<<"\\"<< "n" << (char)34 << "); }; " << endl;
  temp1 << "\t free_dmatrix(py,1,N,1,NPOINTS);  " << endl;
  temp1 << "\t free_dvector(xp,1,NPOINTS); " << endl;
  temp1 << "\t free_dvector(y,1,N); " << endl;
  temp1 << "\t free_dvector(C,1,NINC); " << endl; 
  temp1 << "\t free_dvector(AUX,1,N); " << endl;
  temp1 << "\t free_matrix(FIGS,0,"<<nfigs+1<<",0,NPOINTS);" << endl;
  temp1 << "\t if (resode == 0) { WritePlotScript1(1, "<<nfigs<<", kount, figdata); " << endl;
  temp1 << "\t system(" << char(34) << "rm output1.ps; gnuplot plot.scr &" << char(34) << "); } " << endl;  
  //	temp1 << "\t system(" << char(34) << "gv output1.ps &"<< char(34) << ");  " << endl;  
  };
	 }
  temp1 << "\t end_time = time(NULL); " << endl;  
  temp1 << "\t mydifftime = difftime(end_time, init_time); " << endl; 
  temp1 << "\t printf("<<(char)34 <<"##  %f seconds \\" << "n" << (char)34 << ",mydifftime); " << endl;
  temp1 << "\t return 0; " << endl;
  temp1 << "} " << endl;
  temp1.close();
}


@
