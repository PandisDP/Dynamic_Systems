/*  Program generated by teval1, a translator and LHS/PRCC evaluator written by Jose L. Segovia,  2002-03, for the Kirschner Lab.  */ 
#include <stdio.h> 
#include <stdlib.h> 
#include <math.h>  
#include <time.h>  
#include <string.h> 
#include "datatype.h"
#define NRANSI 
#include "my_nr.h"
#include "nrutil.h"
double dxsav,*xp,**py;  /* defining declarations */ 
int kmax,kount; 
int nrhs;   /* counts function evaluations */ 
#define NINC 9
#define N 14
#define NFigs 7
	 int myreturnsyscall = 0;

void derivs(double TimeAct, double y[], double dydx[], double C[], double AUX[]) 
{
	nrhs++; 
	AUX[1]=  1-C[7];  		 /* umu=1-mu; */
	AUX[2]=  y[7]*y[7]+y[8]*y[8]+y[9]*y[9];  		 /* r2=x1*x1+x2*x2+x3*x3; */
	AUX[3]=  AUX[2]-2*C[7]*y[7]+C[7]*C[7];  		 /* rpe2=r2-2*mu*x1+mu*mu; */
	AUX[4]=  pow(AUX[3],(-3./2));  		 /* rpe3i=pow(rpe2,(-3./2)); */
	AUX[5]=  AUX[2]+2*(1-C[7])*y[7]+(1-C[7])*(1-C[7]);  		 /* rpm2=r2+2*(1-mu)*x1+(1-mu)*(1-mu); */
	AUX[6]=  pow(AUX[5],(-3./2));  		 /* rpm3i=pow(rpm2,(-3./2)); */
	dydx[7]=  y[10]+y[8];  		 /* x1=x4+x2; */
	dydx[8]=  y[11]-y[7];  		 /* x2=x5-x1; */
	dydx[9]=  y[12];  		 /* x3=x6; */
	dydx[10]=  y[11]-(y[7]-C[7])*(AUX[1]*AUX[4])-(y[7]+AUX[1])*(C[7]*AUX[6]);  		 /* x4=x5-(x1-mu)*(umu*rpe3i)-(x1+umu)*(mu*rpm3i); */
	dydx[11]=  -y[10]-y[8]*(AUX[1]*AUX[4]+C[7]*AUX[6]);  		 /* x5=-x4-x2*(umu*rpe3i+mu*rpm3i); */
	dydx[12]=  -y[9]*(AUX[1]*AUX[4]+C[7]*AUX[6]);  		 /* x6=-x3*(umu*rpe3i+mu*rpm3i); */
}
void load_constants(double C[]) {  
	 /* Filling initial conditions */ 
	 C[1] =  -0.45 ; 		 /* x1=-0.45 ; */
	 C[2] =  0.8 ; 		 /* x2=0.8 ; */
	 C[3] =  0.0 ; 		 /* x3=0.0 ; */
	 C[4] =  -0.8 ; 		 /* x4=-0.8 ; */
	 C[5] =  -0.45 ; 		 /* x5=-0.45 ; */
	 C[6] =  0.58 ; 		 /* x6=0.58 ; */
	 C[7] =  0.01025 ; 		 /* mu=0.01025 0.001 0.001 0.02 $U ; */
	 } 
/* End of loading constants */ 
void load_auxlevel(double AUX[], double y[], double C[]) {
	 /* Filling leval and aux variables with initial conditions */ 
	 AUX[1] =  0.0; 	 /* umu = */ 
	 AUX[2] =  0.0; 	 /* r2 = */ 
	 AUX[3] =  0.0; 	 /* rpe2 = */ 
	 AUX[4] =  0.0; 	 /* rpe3i = */ 
	 AUX[5] =  0.0; 	 /* rpm2 = */ 
	 AUX[6] =  0.0; 	 /* rpm3i = */ 
	 y[7] =  C[1]; 	 /* x1 = */ 
	 y[8] =  C[2]; 	 /* x2 = */ 
	 y[9] =  C[3]; 	 /* x3 = */ 
	 y[10] =  C[4]; 	 /* x4 = */ 
	 y[11] =  C[5]; 	 /* x5 = */ 
	 y[12] =  C[6]; 	 /* x6 = */ 
} 


void update_variables_lhs(int c, double C[]) { 
	 /* Updates the following variables at point given by c */ 
	 
	 if (c == 0)   { 
 		 C[7] = 0.0029; 
	 } 
	 if (c == 1)   { 
 		 C[7] = 0.0067; 
	 } 
	 if (c == 2)   { 
 		 C[7] = 0.0105; 
	 } 
	 if (c == 3)   { 
 		 C[7] = 0.0143; 
	 } 
	 if (c == 4)   { 
 		 C[7] = 0.0181; 
	 } 
 } /*  End of update_variables_lhs  */ 


static int nfigsloaded; 
int load_data_figures(double FIGS[][MAX_FIGS], eqfig figdata[], int nfigs, int jj, double y[], double C[], double AUX[], double x, FILE * myfile) { 
	 int j = nfigsloaded; 
	 int i; int errorover=0; 
		  FIGS[0][j] = x; 
		  if (! finite(y[7])) { printf("Overflow error on variable x1 \n"); errorover++; } 
		  FIGS[1][j] = y[7];
		  if (figdata[1].max < FIGS[1][j]) { figdata[1].max =  FIGS[1][j]; } 
		  if (figdata[1].min > FIGS[1][j]) { figdata[1].min =  FIGS[1][j]; } 
		  if (! finite(y[8])) { printf("Overflow error on variable x2 \n"); errorover++; } 
		  FIGS[2][j] = y[8];
		  if (figdata[2].max < FIGS[2][j]) { figdata[2].max =  FIGS[2][j]; } 
		  if (figdata[2].min > FIGS[2][j]) { figdata[2].min =  FIGS[2][j]; } 
		  if (! finite(y[9])) { printf("Overflow error on variable x3 \n"); errorover++; } 
		  FIGS[3][j] = y[9];
		  if (figdata[3].max < FIGS[3][j]) { figdata[3].max =  FIGS[3][j]; } 
		  if (figdata[3].min > FIGS[3][j]) { figdata[3].min =  FIGS[3][j]; } 
		  if (! finite(y[10])) { printf("Overflow error on variable x4 \n"); errorover++; } 
		  FIGS[4][j] = y[10];
		  if (figdata[4].max < FIGS[4][j]) { figdata[4].max =  FIGS[4][j]; } 
		  if (figdata[4].min > FIGS[4][j]) { figdata[4].min =  FIGS[4][j]; } 
		  if (! finite(y[11])) { printf("Overflow error on variable x5 \n"); errorover++; } 
		  FIGS[5][j] = y[11];
		  if (figdata[5].max < FIGS[5][j]) { figdata[5].max =  FIGS[5][j]; } 
		  if (figdata[5].min > FIGS[5][j]) { figdata[5].min =  FIGS[5][j]; } 
	 nfigsloaded ++;
	 if (nfigsloaded >= MAX_FIGS ) { int xx, yy; 
		 for (xx=0;xx<MAX_FIGS;xx++) { 
		 fprintf(myfile,"%f\t",FIGS[0][xx]); 
		  for (yy=1;yy<=5;yy++) 
			  fprintf(myfile, "%.6e\t",FIGS[yy][xx]); 
		 fprintf(myfile,"\n"); 
} nfigsloaded =0; } 
 return errorover; 
} 


int main (void) 
{ 
	 time_t init_time=time(NULL), end_time; double mydifftime;
	 int i,j, resode=0;  int myc=0; 
	 double h, x=1.0, *y, *dydx, *yout, *C, *AUX; 
	 FILE *stream; 
	 char filename[5]; 
	 int nfigs = 5;
	 eqfig figdata[7];
	 double FIGS[7][MAX_FIGS]; 
	 int maxloop =0, nloop =0; int figres=0; 
	 y    =  dvector(1,N);  
	 dydx =  dvector(1,N); 
	 yout =  dvector(1,N);  
	 C   =   dvector(1,NINC); 
	 AUX =   dvector(1,N); 
	 nfigsloaded = 0; 
	 for(i=1;i<=nfigs;i++) { figdata[i].max = -HUGE_VAL; figdata[i].min=HUGE_VAL; }; 
	  strcpy(figdata[1].name,"x1");
	  strcpy(figdata[2].name,"x2");
	  strcpy(figdata[3].name,"x3");
	  strcpy(figdata[4].name,"x4");
	  strcpy(figdata[5].name,"x5");
	 while (myc < 5) { 
	 load_constants(C); 
	 update_variables_lhs(myc, C); 
	 load_auxlevel(AUX,y,C); 
	 nfigsloaded = 0; 
	 /* ---rk4--- */ 
	 h = (double)1e-05;
	 x = (double)0; 
	 maxloop = (int) (40/h)+1;
	 nloop = 0; 
	 j=0; 
	 printf("Solving run %d \n", myc+1);
	 sprintf(filename, "%04u", myc+1); 
	 stream = fopen(filename,"w"  ); 
	 while(nloop <= maxloop) {
		 if (nloop % (int)ceil(0.1/h) == 0) {
		 resode=load_data_figures(FIGS, figdata, nfigs, j, y, C, AUX, x,  stream);
		 if (resode > 0) break; 
			 j++; }  
		 derivs(x,y,dydx,C, AUX); 
		 rk4(y,dydx,N,x,h,yout,derivs, C, AUX); 
		 for(i=0; i<N; i++) 
		 y[i] = yout[i]; 
		 nloop++; 
		 x = x + h;
	 }  
	for(i=0; i<nfigsloaded; i++) { 
		 fprintf(stream,"%f\t",FIGS[0][i]);
		 for(j=1; j<=nfigs; j++) fprintf(stream,"%.5e\t",FIGS[j][i]); 
		 fprintf(stream,"\n"); }; 
		 fclose(stream); 
	 if (resode > 0) { printf( "Error solving run %d \n", myc+1); break;	} 
	 myc++; } 
	 WritePlotScript(1, nfigs, 480, figdata, 0, myc-1);
	 myreturnsyscall = system("rm output1.pdf; gnuplot plot.scr &"); 
	 free_dvector(yout,1,N); 
	 free_dvector(dydx,1,N); 
	 free_dvector(y,1,N); 
	 free_dvector(C,1,NINC); 
	 free_dvector(AUX,1,N); 
	 end_time = time(NULL); 
	 mydifftime = difftime(end_time, init_time); 
	 printf("##  %f seconds \n",mydifftime); 
	 return 0; 
} 
